import requests
import time
from typing import Dict, Any, List
from loguru import logger
from datetime import datetime, timedelta

class VulnerabilityMapper:
    """Maps potential intrusion attempts to known vulnerabilities using NIST NVD API."""
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize the vulnerability mapper.
        
        Args:
            config: Dictionary containing NVD API configuration
        """
        self.api_key = config['api_key']
        self.base_url = config['base_url']
        self.request_delay = config['request_delay']
        self.test_mode = config.get('test_mode', False)
        self._validate_config()
    
    def _validate_config(self):
        """Validate the configuration."""
        if not self.api_key and not self.test_mode:
            logger.warning("No API key provided for NVD API. Some features may be limited.")
    
    def map_vulnerabilities(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """
        Map analysis results to potential vulnerabilities.
        
        Args:
            analysis_results: Dictionary containing analysis results
        
        Returns:
            Dictionary containing vulnerability mapping results
        """
        if self.test_mode:
            return self._generate_test_results(analysis_results)
            
        vulnerabilities = {}
        
        # Extract relevant information from analysis results
        suspicious_ips = analysis_results.get('ip_analysis', {}).get('suspicious_ips', [])
        pattern_matches = analysis_results.get('pattern_matches', {}).get('matches', {})
        
        # Map vulnerabilities for suspicious IPs
        ip_vulnerabilities = self._map_ip_vulnerabilities(suspicious_ips)
        
        # Map vulnerabilities for detected patterns
        pattern_vulnerabilities = self._map_pattern_vulnerabilities(pattern_matches)
        
        return {
            'ip_vulnerabilities': ip_vulnerabilities,
            'pattern_vulnerabilities': pattern_vulnerabilities,
            'summary': self._generate_summary(ip_vulnerabilities, pattern_vulnerabilities)
        }
    
    def _generate_test_results(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate test results when no API key is available."""
        suspicious_ips = analysis_results.get('ip_analysis', {}).get('suspicious_ips', [])
        
        ip_vulnerabilities = {}
        for ip_data in suspicious_ips:
            ip = ip_data['ip']
            ip_vulnerabilities[ip] = {
                'potential_vulnerabilities': [
                    {
                        'id': 'CVE-2023-38408',
                        'description': 'OpenSSH before 9.3p2 allows remote attackers to conduct brute force attacks due to insufficient rate limiting',
                        'severity': 'HIGH',
                        'published': '2023-07-19T00:00:00',
                        'references': [
                            'https://nvd.nist.gov/vuln/detail/CVE-2023-38408',
                            'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-38408'
                        ],
                        'mitigation': 'Update OpenSSH to version 9.3p2 or later and implement rate limiting',
                        'attack_vector': 'Network',
                        'impact': {
                            'confidentiality': 'HIGH',
                            'integrity': 'HIGH',
                            'availability': 'MEDIUM'
                        }
                    }
                ],
                'attack_pattern': 'Potential brute force attempt',
                'risk_level': 'HIGH'
            }
        
        pattern_vulnerabilities = {
            'Failed password': [
                {
                    'id': 'CVE-2023-28531',
                    'description': 'OpenSSH before 9.3p2 allows remote attackers to bypass authentication via timing attack',
                    'severity': 'MEDIUM',
                    'published': '2023-04-19T00:00:00',
                    'references': [
                        'https://nvd.nist.gov/vuln/detail/CVE-2023-28531',
                        'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-28531'
                    ],
                    'mitigation': 'Update OpenSSH to version 9.3p2 or later and implement standardized response times',
                    'attack_vector': 'Network',
                    'impact': {
                        'confidentiality': 'MEDIUM',
                        'integrity': 'MEDIUM',
                        'availability': 'LOW'
                    }
                }
            ],
            'Invalid user': [
                {
                    'id': 'CVE-2023-48795',
                    'description': 'OpenSSH before 9.6p1 allows remote attackers to conduct user enumeration attacks',
                    'severity': 'MEDIUM',
                    'published': '2023-12-18T00:00:00',
                    'references': [
                        'https://nvd.nist.gov/vuln/detail/CVE-2023-48795',
                        'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-48795'
                    ],
                    'mitigation': 'Update OpenSSH to version 9.6p1 or later and implement user enumeration protection',
                    'attack_vector': 'Network',
                    'impact': {
                        'confidentiality': 'MEDIUM',
                        'integrity': 'LOW',
                        'availability': 'LOW'
                    }
                }
            ]
        }
        
        return {
            'ip_vulnerabilities': ip_vulnerabilities,
            'pattern_vulnerabilities': pattern_vulnerabilities,
            'summary': {
                'total_vulnerabilities': len(suspicious_ips) + len(pattern_vulnerabilities),
                'severity_distribution': {
                    'CRITICAL': 0,
                    'HIGH': len(suspicious_ips),
                    'MEDIUM': len(pattern_vulnerabilities),
                    'LOW': 0
                },
                'cve_references': {
                    'total_cves': len(suspicious_ips) + len(pattern_vulnerabilities),
                    'by_severity': {
                        'HIGH': ['CVE-2023-38408'],
                        'MEDIUM': ['CVE-2023-28531', 'CVE-2023-48795'],
                        'LOW': []
                    }
                },
                'timestamp': datetime.now().isoformat(),
                'overall_risk_level': 'HIGH' if suspicious_ips else 'MEDIUM'
            }
        }
    
    def _map_ip_vulnerabilities(self, suspicious_ips: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Map suspicious IPs to potential vulnerabilities.
        
        Args:
            suspicious_ips: List of suspicious IP data
        
        Returns:
            Dictionary containing IP-based vulnerability mapping
        """
        ip_vulns = {}
        
        for ip_data in suspicious_ips:
            ip = ip_data['ip']
            # Search for vulnerabilities related to SSH brute force attempts
            search_terms = [
                "SSH brute force",
                "password guessing",
                "authentication bypass"
            ]
            
            vulnerabilities = []
            for term in search_terms:
                vulns = self._query_nvd(term)
                if vulns:
                    vulnerabilities.extend(vulns)
                time.sleep(self.request_delay)  # Respect API rate limits
            
            ip_vulns[ip] = {
                'potential_vulnerabilities': vulnerabilities,
                'attack_pattern': 'Potential brute force attempt',
                'risk_level': self._calculate_vulnerability_risk(vulnerabilities)
            }
        
        return ip_vulns
    
    def _map_pattern_vulnerabilities(self, pattern_matches: Dict[str, List[Dict[str, Any]]]) -> Dict[str, Any]:
        """
        Map detected patterns to potential vulnerabilities.
        
        Args:
            pattern_matches: Dictionary containing pattern match data
        
        Returns:
            Dictionary containing pattern-based vulnerability mapping
        """
        pattern_vulns = {}
        
        for pattern, matches in pattern_matches.items():
            # Convert pattern to relevant search terms
            search_terms = self._pattern_to_search_terms(pattern)
            
            vulnerabilities = []
            for term in search_terms:
                vulns = self._query_nvd(term)
                if vulns:
                    vulnerabilities.extend(vulns)
                time.sleep(self.request_delay)  # Respect API rate limits
            
            pattern_vulns[pattern] = {
                'potential_vulnerabilities': vulnerabilities,
                'match_count': len(matches),
                'risk_level': self._calculate_vulnerability_risk(vulnerabilities)
            }
        
        return pattern_vulns
    
    def _query_nvd(self, keyword: str) -> List[Dict[str, Any]]:
        """
        Query the NVD API for vulnerabilities.
        
        Args:
            keyword: Search term for vulnerability query
        
        Returns:
            List of vulnerability data
        """
        try:
            headers = {'apiKey': self.api_key} if self.api_key else {}
            
            # Calculate date range for last 30 days
            end_date = datetime.now()
            start_date = end_date - timedelta(days=30)
            
            params = {
                'keywordSearch': keyword,
                'pubStartDate': start_date.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z',
                'pubEndDate': end_date.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            }
            
            response = requests.get(
                self.base_url,
                headers=headers,
                params=params
            )
            
            if response.status_code == 200:
                data = response.json()
                vulnerabilities = data.get('vulnerabilities', [])
                
                # Extract relevant information
                return [{
                    'cve_id': vuln['cve']['id'],
                    'description': vuln['cve']['descriptions'][0]['value'],
                    'severity': self._get_severity(vuln),
                    'published': vuln['cve']['published'],
                    'references': [ref['url'] for ref in vuln['cve'].get('references', [])]
                } for vuln in vulnerabilities]
            else:
                logger.error(f"NVD API request failed with status {response.status_code}")
                return []
                
        except Exception as e:
            logger.error(f"Error querying NVD API: {str(e)}")
            return []
    
    def _pattern_to_search_terms(self, pattern: str) -> List[str]:
        """
        Convert a log pattern to relevant vulnerability search terms.
        
        Args:
            pattern: Log pattern string
        
        Returns:
            List of search terms
        """
        pattern_mapping = {
            'Failed password': ['SSH brute force', 'password attack'],
            'Invalid user': ['user enumeration', 'authentication bypass'],
            'Connection closed': ['SSH connection exploitation', 'DoS SSH'],
            'Did not receive identification': ['SSH protocol violation', 'SSH version exploitation']
        }
        
        return pattern_mapping.get(pattern, [pattern])
    
    def _get_severity(self, vulnerability: Dict[str, Any]) -> str:
        """
        Extract severity information from vulnerability data.
        
        Args:
            vulnerability: Vulnerability data dictionary
        
        Returns:
            String indicating severity level
        """
        metrics = vulnerability.get('cve', {}).get('metrics', {})
        
        # Check for CVSS v3.1 score first
        if 'cvssMetricV31' in metrics:
            return metrics['cvssMetricV31'][0]['cvssData']['baseScore']
        # Fall back to CVSS v3.0
        elif 'cvssMetricV30' in metrics:
            return metrics['cvssMetricV30'][0]['cvssData']['baseScore']
        # Fall back to CVSS v2.0
        elif 'cvssMetricV2' in metrics:
            return metrics['cvssMetricV2'][0]['cvssData']['baseScore']
        
        return "N/A"
    
    def _calculate_vulnerability_risk(self, vulnerabilities: List[Dict[str, Any]]) -> str:
        """
        Calculate risk level based on vulnerability data.
        
        Args:
            vulnerabilities: List of vulnerability dictionaries
        
        Returns:
            String indicating risk level
        """
        if not vulnerabilities:
            return "LOW"
        
        # Calculate average severity
        severities = [float(v['severity']) for v in vulnerabilities 
                     if v['severity'] != "N/A"]
        
        if not severities:
            return "LOW"
        
        avg_severity = sum(severities) / len(severities)
        
        if avg_severity >= 9.0:
            return "CRITICAL"
        elif avg_severity >= 7.0:
            return "HIGH"
        elif avg_severity >= 4.0:
            return "MEDIUM"
        return "LOW"
    
    def _generate_summary(self, ip_vulnerabilities: Dict[str, Any],
                         pattern_vulnerabilities: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate a summary of vulnerability mapping results.
        
        Args:
            ip_vulnerabilities: Results from IP-based vulnerability mapping
            pattern_vulnerabilities: Results from pattern-based vulnerability mapping
        
        Returns:
            Dictionary containing vulnerability mapping summary
        """
        # Count vulnerabilities by severity
        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
        
        # Count IP-based vulnerabilities
        for ip_data in ip_vulnerabilities.values():
            severity_counts[ip_data['risk_level']] += 1
        
        # Count pattern-based vulnerabilities
        for pattern_data in pattern_vulnerabilities.values():
            severity_counts[pattern_data['risk_level']] += 1
        
        return {
            'total_vulnerabilities': sum(len(ip_data['potential_vulnerabilities'])
                                       for ip_data in ip_vulnerabilities.values()) +
                                   sum(len(pattern_data['potential_vulnerabilities'])
                                       for pattern_data in pattern_vulnerabilities.values()),
            'severity_distribution': severity_counts,
            'timestamp': datetime.now().isoformat(),
            'overall_risk_level': self._calculate_overall_risk(severity_counts)
        }
    
    def _calculate_overall_risk(self, severity_counts: Dict[str, int]) -> str:
        """
        Calculate overall risk level based on vulnerability severity distribution.
        
        Args:
            severity_counts: Dictionary containing counts of vulnerabilities by severity
        
        Returns:
            String indicating overall risk level
        """
        if severity_counts['CRITICAL'] > 0:
            return "CRITICAL"
        elif severity_counts['HIGH'] > 2:
            return "HIGH"
        elif severity_counts['HIGH'] > 0 or severity_counts['MEDIUM'] > 3:
            return "MEDIUM"
        return "LOW" 